// Generated by CoffeeScript 1.6.3
(function() {
  var Alternatives, Markdown, Multiple, PostposedExecution, PrimitiveAlternatives, Tuple, a, action, actionDefinition, actionName, am, baseUri, body, bodySchema, boolean, chapter, curr, d3fault, defaultMediaTypes, description, documentation, enum2, example, excludes, formParameters, getSpaces, header, headers, i, include, integer, jsonSchema, m, map, markdown, maxLength, maximum, mimeType, mimeTypeParameters, minLength, minimum, mm, model, name, pa, pam, parameterProperty, path, pattern, pr, prm, provides, queryParameterDefinition, queryParameters, regex, required, requires, resource, resourceDefinition, responseCode, responses, root, rootElement, schemas, string, suggest, summary, t, title, tm, trait, traitDefinition, traits, transverse, typ3, type, typeIsArray, uriParameter, uriParameters, use, version, xmlSchema,
    __slice = [].slice;

  typeIsArray = Array.isArray || function(value) {
    return {}.toString.call(value) === '[object Array]';
  };

  typ3 = function(obj) {
    var classToType, myClass, name, _i, _len, _ref;
    if (obj === void 0 || obj === null) {
      return String(obj);
    }
    classToType = new Object;
    _ref = "Boolean Number String Function Array Date RegExp".split(" ");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    myClass = Object.prototype.toString.call(obj);
    if (myClass in classToType) {
      return classToType[myClass];
    }
    return "object";
  };

  Tuple = (function() {
    function Tuple(key, value) {
      this.key = key;
      this.value = value;
      if (typ3(this.key) !== 'string') {
        throw "Key: '" + (JSON.stringify(key)) + "' of type '" + (typ3(key)) + "' must be an string";
      }
    }

    return Tuple;

  })();

  Alternatives = (function() {
    function Alternatives() {
      var alternatives;
      alternatives = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.alternatives = alternatives;
    }

    return Alternatives;

  })();

  PrimitiveAlternatives = (function() {
    function PrimitiveAlternatives() {
      var alternatives;
      alternatives = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.alternatives = alternatives;
    }

    return PrimitiveAlternatives;

  })();

  Multiple = (function() {
    function Multiple(element) {
      this.element = element;
    }

    return Multiple;

  })();

  PostposedExecution = (function() {
    function PostposedExecution(f) {
      this.f = f;
    }

    return PostposedExecution;

  })();

  markdown = '<markdown>';

  include = '<include>';

  string = '<string>';

  path = '<path>';

  jsonSchema = '<jsonSchema>';

  regex = '<regex>';

  integer = '<int>';

  boolean = '<bool>';

  xmlSchema = '<xmlSchema>';

  Markdown = new Alternatives(markdown, include);

  path = string;

  include = include;

  title = new Tuple('title', string);

  version = new Tuple('version', string);

  model = new Tuple(string, jsonSchema);

  schemas = new Tuple('schemas', new Multiple(model));

  baseUri = new Tuple('baseUri', string);

  name = new Tuple('name', string);

  description = new Tuple('description', string);

  type = new Tuple('type', new PrimitiveAlternatives('string', 'number', 'integer', 'date'));

  enum2 = new Tuple('enum', new Multiple(string));

  pattern = new Tuple('pattern', regex);

  minLength = new Tuple('minLength', integer);

  maxLength = new Tuple('maxLength', integer);

  minimum = new Tuple('minimum', integer);

  maximum = new Tuple('maximum', integer);

  required = new Tuple('required', boolean);

  d3fault = new Tuple('default', string);

  requires = new Tuple('requires', new Multiple(string));

  provides = new Tuple('provides', new Multiple(string));

  excludes = new Tuple('excludes', new Multiple(string));

  parameterProperty = new Alternatives(name, description, type, enum2, pattern, minLength, maxLength, maximum, minimum, required, d3fault, requires, excludes);

  uriParameter = new Tuple(string, new Multiple(parameterProperty));

  uriParameters = new Tuple('uriParameters', new Multiple(uriParameter));

  defaultMediaTypes = new Tuple('defaultMediaTypes', new PrimitiveAlternatives(string, new Multiple(string)));

  chapter = new Alternatives(new Tuple('title', string), new Tuple('content', string));

  documentation = new Tuple('documentation', new Multiple(chapter));

  summary = new Tuple('summary', string);

  example = new Tuple('example', string);

  header = new Tuple(string, new Multiple(new Alternatives(parameterProperty, example)));

  headers = new Tuple('headers', new Multiple(header));

  queryParameterDefinition = new Tuple(string, new Multiple(new Alternatives(parameterProperty, example)));

  queryParameters = new Tuple('queryParameters', new Multiple(queryParameterDefinition));

  formParameters = new Tuple('formParameters', new Multiple(new Alternatives(parameterProperty, example)));

  bodySchema = new Tuple('schema', new PrimitiveAlternatives(xmlSchema, jsonSchema));

  mimeTypeParameters = new Multiple(new Alternatives(bodySchema, example));

  mimeType = new Alternatives(new Tuple('application/x-www-form-urlencoded', new Multiple(formParameters)), new Tuple('multipart/form-data', new Multiple(formParameters)), new Tuple(string, new Multiple(mimeTypeParameters)));

  body = new Tuple('body', new Multiple(mimeType));

  responseCode = new Tuple(integer, new Multiple(integer), new Multiple(new Alternatives(body, description)));

  responses = new Tuple('responses', new Multiple(responseCode));

  actionDefinition = new Alternatives(summary, description, headers, queryParameters, body, responses);

  action = (function(func, args, ctor) {
    ctor.prototype = func.prototype;
    var child = new ctor, result = func.apply(child, args);
    return Object(result) === result ? result : child;
  })(Alternatives, (function() {
    var _i, _len, _ref, _results;
    _ref = ['get', 'post', 'put', 'delete', 'head', 'path', 'options'];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      actionName = _ref[_i];
      _results.push(new Tuple(actionName, new Multiple(actionDefinition)));
    }
    return _results;
  })(), function(){});

  use = new Tuple('use', new Multiple(string));

  resourceDefinition = new Alternatives(name, action, use, new Tuple(string, new PostposedExecution(function() {
    return resourceDefinition;
  })));

  resource = new Tuple(string, new Multiple(resourceDefinition));

  traitDefinition = new Tuple(string, new Multiple(new Alternatives(description, provides, requires)));

  trait = new Tuple('traits', traitDefinition);

  traits = new Multiple(trait);

  rootElement = new Alternatives(title, version, schemas, baseUri, uriParameters, defaultMediaTypes, documentation, resource, traits);

  root = new Multiple(rootElement);

  transverse = function(root, fa, ft, fm, fpa, fpr) {
    var a, alternative, alternatives, b, m, promise;
    switch (false) {
      case !(root instanceof Alternatives):
        alternatives = (function() {
          var _i, _len, _ref, _results;
          _ref = root.alternatives;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            alternative = _ref[_i];
            _results.push(transverse(alternative, fa, ft, fm, fpa, fpr));
          }
          return _results;
        })();
        return fa(root, alternatives);
      case !(root instanceof Tuple):
        a = transverse(root.key, fa, ft, fm, fpa, fpr);
        b = transverse(root.value, fa, ft, fm, fpa, fpr);
        return ft(root, a, b);
      case !(root instanceof Multiple):
        m = transverse(root.element, fa, ft, fm, fpa, fpr);
        return fm(root, m);
      case !(root instanceof PrimitiveAlternatives):
        alternatives = (function() {
          var _i, _len, _ref, _results;
          _ref = root.alternatives;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            alternatives = _ref[_i];
            _results.push(transverse(alternatives, fa, ft, fm, fpa, fpr));
          }
          return _results;
        })();
        return fpa(root, alternatives);
      case !(root instanceof PostposedExecution):
        promise = new PostposedExecution(function() {
          return transverse(root.f(), fa, ft, fm, fpa, fpr);
        });
        return fpr(root, promise);
      case typeof root !== 'string':
        return root;
      default:
        throw 'Invalid state: ' + typ3(root) + ' ' + JSON.stringify(root);
    }
  };

  i = 0;

  getSpaces = function() {
    var num;
    return ((function() {
      var _i, _results;
      _results = [];
      for (num = _i = 1; 1 <= i ? _i <= i : _i >= i; num = 1 <= i ? ++_i : --_i) {
        _results.push(' ');
      }
      return _results;
    })()).join('');
  };

  a = function(root, alternatives) {
    var res;
    i = i + 1;
    res = '(' + getSpaces() + alternatives.join(' | ') + ')';
    i = i - 1;
    return res;
  };

  t = function(root, key, value) {
    var res;
    i = i + 1;
    res = '(' + key + ': ' + value + ')';
    i = i - 1;
    return res;
  };

  m = function(root, element) {
    var res;
    i = i + 1;
    res = '[' + getSpaces() + element + ']';
    i = i - 1;
    return res;
  };

  pa = function(root, element) {
    var res;
    i = i + 1;
    res = '(' + getSpaces() + alternatives.join(' | ') + ')';
    i = i - 1;
    return res;
  };

  pr = function(root, promise) {
    return promise;
  };

  m = {};

  curr = m;

  am = function(root, alternatives) {
    var alternative, d, key, value, _i, _len;
    d = {};
    for (_i = 0, _len = alternatives.length; _i < _len; _i++) {
      alternative = alternatives[_i];
      for (key in alternative) {
        value = alternative[key];
        d[key] = value;
      }
    }
    return d;
  };

  tm = function(root, key, value) {
    var d, k, kind, _i, _j, _len, _len1;
    d = {};
    kind = typ3(key);
    switch (kind) {
      case 'Array':
        for (_i = 0, _len = key.length; _i < _len; _i++) {
          k = key[_i];
          switch (typ3(k)) {
            case 'string':
              d[k] = function() {
                return value;
              };
              break;
            default:
              throw k;
          }
        }
        break;
      case 'object':
        for (_j = 0, _len1 = key.length; _j < _len1; _j++) {
          k = key[_j];
          switch (typ3(k)) {
            case 'string':
              d[k] = function() {
                return value;
              };
              break;
            default:
              throw k;
          }
        }
        break;
      default:
        if (typ3(value) !== 'function') {
          d[key] = function() {
            return value;
          };
        } else {
          d[key] = value;
        }
    }
    return d;
  };

  mm = function(root, element) {
    return element;
  };

  pam = function(root, alternatives) {
    return alternatives;
  };

  prm = function(root, promise) {
    return promise.f;
  };

  map = transverse(root, am, tm, mm, pam, prm);

  suggest = function() {
    var index, key, path, root, val;
    root = arguments[0], index = arguments[1], path = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    key = path[index];
    if (path[index] == null) {
      return root;
    }
    val = root[key];
    if (val == null) {
      val = root['<string>'];
    }
    if (typ3(val) === 'function') {
      val = val();
    }
    return suggest.apply(null, [val, index + 1].concat(__slice.call(path)));
  };

  console.log(suggest(map, 0, '/pet', '/hello', '/bye', 'get', 'queryParameters', 'limit', 'default'));

  window.suggest2 = function(array) {
      var a = array.slice(0);
      a.unshift(0);
      a.unshift(map);
      return suggest.apply(this, a);
    
  }

}).call(this);
